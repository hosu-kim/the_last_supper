```bash
the_oracle/
├── LICENSE                # 프로젝트의 라이선스 파일
├── Makefile               # 빌드 스크립트
├── README.md              # 프로젝트 설명 및 사용법 안내
├── include/               # 헤더 파일 디렉토리
│   ├── philosophers.h     # 철학자 관련 구조체, 함수 선언
│   ├── simulation.h       # 시뮬레이션 관리용 함수 선언
│   └── utils.h            # 공통 유틸리티 함수 선언
└── src/                   # 소스 코드 디렉토리
    ├── main.c             # 프로그램 실행의 진입점
    ├── philosophers.c     # 철학자 동작 구현
    ├── simulation.c       # 시뮬레이션 로직 구현
    └── utils.c            # 공통 유틸리티 함수 구현
```

문제 이해: 철학자들의 식사 문제를 이해하는 것이 중요합니다. 여러 철학자들이 원탁에 앉아 있고, 각 철학자 사이에는 포크가 하나씩 놓여 있습니다. 철학자는 생각하거나, 배가 고프면 양쪽의 포크를 모두 집어 식사를 합니다. 교착 상태(deadlock)나 기아 상태(starvation) 없이 이 시뮬레이션을 구현해야 합니다.
스레드 및 뮤텍스 학습: 이 프로젝트는 멀티스레딩의 기본 개념과 뮤텍스(mutex)를 사용하여 공유 자원(포크)에 대한 접근을 제어하는 방법을 이해해야 합니다.
스레드 생성: 각 철학자를 별도의 스레드로 나타냅니다.
뮤텍스 사용: 각 포크를 뮤텍스로 보호하여 한 번에 한 철학자만 사용할 수 있도록 합니다.
구현:
철학자들은 "생각 중", "배고픔", "식사 중", "잠자는 중" 상태를 가질 수 있습니다.
각 철학자는 정해진 횟수만큼 식사를 하거나, 철학자 중 한 명이 죽으면 시뮬레이션이 종료될 수 있습니다. (프로젝트 요구사항에 따라 다름)
철학자의 상태가 변경될 때마다 로그를 출력해야 합니다. (예: [timestamp_in_ms] [philosopher_index] [action])
교착 상태 방지: 모든 철학자가 동시에 왼쪽 포크를 집고 오른쪽 포크를 기다리는 상황과 같은 교착 상태를 방지하는 로직을 구현해야 합니다. 일반적인 해결책 중 하나는 철학자들이 포크를 집는 순서에 규칙을 두는 것입니다 (예: 짝수/홀수 철학자는 다른 순서로 포크를 집도록 하거나, 한 번에 하나의 철학자만 포크를 집도록 허용).
기아 상태 방지: 특정 철학자가 계속해서 포크를 얻지 못해 굶어 죽는 상황을 방지해야 합니다.
정확한 시간 측정 및 로그: 프로젝트 요구사항에 따라 정확한 시간 측정 및 상태 변화에 대한 로그 출력이 중요합니다.
테스트 및 디버깅: 다양한 시나리오(철학자 수, 식사 시간, 생각 시간 등)를 테스트하여 프로그램이 올바르게 작동하고 교착 상태나 경쟁 조건이 없는지 확인합니다.
다음은 이 프로젝트에 대한 몇 가지 유용한 자료입니다:

GitHub 리포지토리 예시:
furkangny/Philosophers: C언어와 멀티스레딩을 사용하여 교착 상태와 자원 충돌을 방지하는 해결책을 제공합니다.
1337fury/42_philosopher: 철학자들이 먹고, 생각하고, 자는 것을 번갈아 하는 원탁 시뮬레이션입니다.
TommyJD93/Philosophers: 42 school을 위한 철학자들의 식사 문제 가이드입니다.
가이드 및 설명:
Philosophers project from 42 network walk through.. - YouTube: 스레드 생성 및 뮤텍스 사용법을 포함한 프로젝트 설명 영상입니다.
Building the thing | Guide - GitBook: 스레드 작동 방식과 뮤텍스를 사용하여 값을 잠그거나 푸는 방법을 이해하는 것이 중요하다고 강조합니다.
이러한 자료들이 프로젝트를 시작하고 완료하는 데 도움이 되기를 바랍니다. 프로젝트의 구체적인 요구 사항은 42 과정의 지침을 따르는 것이 가장 중요합니다.

You said: 그러면 단계와 그 안에서 할일을 나열해줄래?
그러면 단계와 그 안에서 할일을 나열해줄래?
Copilot said: 알겠습니다. "42 philosophers" 프로젝트를 위한 단계별 할
알겠습니다. "42 philosophers" 프로젝트를 위한 단계별 할 일을 자세히 나열해 드리겠습니다.

1단계: 문제 정의 및 이해 (Problem Definition and Understanding)

할 일:
철학자들의 식사 문제(Dining Philosophers Problem)의 규칙과 목표를 명확히 이해합니다.
원탁에 앉은 철학자들
각 철학자 사이의 포크 (공유 자원)
철학자의 세 가지 상태: 생각(thinking), 배고픔(hungry), 식사(eating) (그리고 잠자기(sleeping)도 추가될 수 있습니다)
교착 상태(deadlock)가 발생하는 조건과 이를 피해야 하는 이유를 학습합니다.
기아 상태(starvation)가 발생하는 조건과 이를 방지해야 하는 이유를 학습합니다.
42 서울 캠퍼스에서 제공하는 해당 과제의 구체적인 요구사항(subject 파일)을 꼼꼼히 읽고 숙지합니다. (예: 입력 인자, 출력 형식, 허용 함수, 평가 기준 등)
2단계: 핵심 개념 학습 (Learning Core Concepts)

할 일:
프로세스(Process)와 스레드(Thread)의 차이점을 학습합니다.
스레드 생성 및 관리:
pthread_create(): 스레드를 생성하는 방법
pthread_join(): 특정 스레드가 종료될 때까지 기다리는 방법
pthread_exit(): 스레드를 종료하는 방법 (선택적)
스레드에 인자를 전달하고 반환 값을 받는 방법
뮤텍스(Mutex)의 개념과 사용법:
pthread_mutex_init(): 뮤텍스를 초기화하는 방법
pthread_mutex_destroy(): 뮤텍스를 파괴하는 방법
pthread_mutex_lock(): 뮤텍스를 잠그는 방법 (임계 구역 진입)
pthread_mutex_unlock(): 뮤텍스를 푸는 방법 (임계 구역 탈출)
pthread_mutex_trylock(): 뮤텍스를 잠그려고 시도하고, 잠겨있으면 즉시 리턴하는 방법 (선택적)
경쟁 조건(Race Condition): 여러 스레드가 공유 자원에 동시에 접근하여 예상치 못한 결과가 발생하는 상황을 이해하고, 뮤텍스를 통해 이를 방지하는 방법을 익힙니다.
시간 함수:
gettimeofday(): 현재 시간을 마이크로초 단위까지 얻는 방법 (타임스탬프 및 시간 계산에 사용)
usleep(): 지정된 시간(마이크로초) 동안 실행을 중단하는 방법 (철학자의 생각, 식사, 수면 시간 구현)
3단계: 설계 (Design)

할 일:
데이터 구조 설계:
철학자 정보를 담을 구조체 정의 (ID, 상태, 식사 횟수, 마지막 식사 시간 등)
포크(뮤텍스) 배열 또는 각 철학자가 접근할 포크의 인덱스를 관리할 방법 설계
전체 시뮬레이션 상태를 관리할 구조체 정의 (철학자 수, 생존 시간, 식사 시간, 수면 시간, 최소 식사 횟수, 시뮬레이션 시작 시간, 종료 플래그 등)
철학자의 행동 흐름 설계:
생각 -> 배고픔 -> 포크 집기 시도 -> 식사 -> 포크 내려놓기 -> 잠자기 (요구사항에 따라 순서나 상태는 변경될 수 있음)
교착 상태 방지 전략 수립:
예시 1: 모든 철학자가 왼쪽 포크를 먼저 집고 오른쪽 포크를 집도록 하되, 마지막 철학자는 오른쪽 포크를 먼저 집도록 순서를 바꾼다.
예시 2: 짝수 번호 철학자는 왼쪽->오른쪽, 홀수 번호 철학자는 오른쪽->왼쪽 순으로 포크를 집는다.
예시 3: 한 번에 하나의 철학자만 포크를 집도록 허용하는 전역 뮤텍스(게이트키퍼)를 사용한다. (단, 이는 병렬성을 크게 해칠 수 있음)
기아 상태 방지 전략 고려 (선택 사항이지만 중요):
철학자가 너무 오래 굶고 있다면 우선순위를 높여주는 방법 등을 고민합니다. (과제 요구사항에 따라 구현 여부 결정)
프로그램 종료 조건 명확화:
모든 철학자가 최소 식사 횟수를 만족했을 때
철학자 중 한 명이 굶어 죽었을 때 (생존 시간 초과)
로그 출력 형식 및 시점 설계:
과제에서 요구하는 정확한 형식(timestamp_in_ms X has taken a fork, timestamp_in_ms X is eating 등)을 파악하고, 각 상태 변화 시점에 로그를 출력하도록 설계합니다.
4단계: 구현 (Implementation)

할 일:
인자 파싱: main 함수에서 프로그램 실행 시 전달되는 인자들(철학자 수, 생존 시간 등)을 올바르게 파싱하고 유효성을 검사합니다.
초기화:
철학자 정보(구조체) 및 상태 초기화
포크에 해당하는 뮤텍스 배열 초기화 (pthread_mutex_init)
시뮬레이션 시작 시간 기록 (gettimeofday)
철학자 스레드 생성: pthread_create를 사용하여 각 철학자에 대한 스레드를 생성하고, 각 스레드가 실행할 함수(철학자의 행동 로직)를 지정합니다.
철학자 행동 로직 구현 (스레드 함수 내):
무한 루프 또는 종료 조건 만족 시까지 반복
think(): usleep을 사용하여 생각하는 시간만큼 대기하고 로그 출력
take_forks(): 설계한 교착 상태 방지 전략에 따라 양쪽 포크(뮤텍스)를 pthread_mutex_lock으로 획득하고 로그 출력
eat(): usleep을 사용하여 식사하는 시간만큼 대기, 식사 횟수 증가, 마지막 식사 시간 갱신, 로그 출력
put_forks(): 양쪽 포크(뮤텍스)를 pthread_mutex_unlock으로 반납하고 로그 출력 (선택적 로그)
sleep(): usleep을 사용하여 잠자는 시간만큼 대기하고 로그 출력
모니터링 스레드 또는 로직 구현 (선택 사항이지만 권장):
주기적으로 각 철학자의 상태(특히 마지막 식사 시간)를 검사하여 굶어 죽는 철학자가 있는지 확인합니다.
모든 철학자가 최소 식사 횟수를 만족했는지 확인하여 시뮬레이션을 정상 종료시킵니다.
시간 계산 및 로그 출력 함수: 정확한 타임스탬프(시뮬레이션 시작 후 경과 시간(ms))를 계산하고, 요구된 형식으로 로그를 출력하는 함수를 만듭니다.
자원 정리: 시뮬레이션 종료 시 모든 뮤텍스를 pthread_mutex_destroy로 파괴하고, 할당된 메모리를 해제합니다.
스레드 종료 대기: main 함수에서 pthread_join을 사용하여 모든 철학자 스레드가 종료될 때까지 기다립니다.
5단계: 테스트 및 디버깅 (Testing and Debugging)

할 일:
다양한 시나리오 테스트:
철학자 수가 적을 때 (예: 1명, 2명)
철학자 수가 많을 때
생존 시간, 식사 시간, 수면 시간이 매우 짧거나 길 때
최소 식사 횟수가 0이거나 매우 클 때
교착 상태 발생 여부 집중 확인: 프로그램이 멈추는지 관찰합니다.
기아 상태 발생 여부 확인: 특정 철학자만 계속 식사를 못 하는지 로그를 통해 확인합니다.
로그 출력 정확성 검증: 타임스탬프, 철학자 번호, 행동 메시지가 정확한지 확인합니다.
경쟁 조건 검사: ThreadSanitizer (컴파일 옵션 -fsanitize=thread)와 같은 도구를 사용하여 경쟁 조건을 탐지합니다. (사용 가능하다면)
메모리 누수 검사: Valgrind와 같은 도구를 사용하여 메모리 누수가 없는지 확인합니다. (사용 가능하다면)
에러 처리: 잘못된 인자 입력 시 적절한 에러 메시지를 출력하고 종료하는지 확인합니다.
6단계: 최적화 및 개선 (Optimization and Refinement - 선택 사항)

할 일:
코드의 가독성을 높이고 중복을 제거합니다.
더 효율적인 교착 상태/기아 상태 방지 알고리즘이 있다면 적용을 고려합니다. (단, 과제 요구사항을 벗어나지 않는 선에서)
불필요한 뮤텍스 사용을 줄여 병렬성을 높일 수 있는지 검토합니다.
7단계: 문서화 및 제출 (Documentation and Submission)

할 일:
코드 내에 적절한 주석을 작성하여 로직을 설명합니다.
Makefile을 작성하여 컴파일 및 실행이 용이하도록 합니다. (42 과제 표준)
과제 제출 시스템의 규칙에 맞춰 파일을 정리하고 제출합니다.